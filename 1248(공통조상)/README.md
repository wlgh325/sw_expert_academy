# sw expert academy 1248 공통조상 자바(java)  풀이
- 난이도 : D5
- sw expert academy 1248 공통조상 문제 자바 풀이
- [sw expert academy 1248 공통조상](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15PTkqAPYCFAYD)

## [티스토리 주소](https://hoho325.tistory.com/)

# 문제정리
1. 두 정점의 공통 조상 중 가장 가까운 것을 찾아라.
2. 공통 조상을 루트로 하는 서브트리의 크기를 알아내라
3. 간선은 주어질때 '부모 자식'순으로 주어진다.

# 문제풀이
이 문제는 두가지 방법을 이용해 풀어봤습니다.  
첫 번째는 naive하게 생각하여 푼 방법이고 두번째는 LCA라는 알고리즘 기법을 이용하였습니다.  
그리고 이 문제에서 중요한점은 그래프를 표현할때 인접행렬을 이용할 수 없습니다.  
9번째 tc까지는 가능하지만 10번째 tc에서 메모리 초과가 나옵니다. 여기서 인접행렬의 단점을 엿볼 수 있습니다.  
10번째 tc를 인접행렬로 표현하면 10000x10000 배열이 되기 때문에 엄청난 메모리 낭비가 생깁니다.  
그래서 두가지 방법 모두 인접리스트를 이용해야 합니다!!!!  

# dfs를 통한 단순 검색
1. 인접리스트로 그래프를 만듭니다. 이때 인접리스트는 다음과 같은 정보를 나타냅니다.
    * i번째 list는 i번째 점과 연결된 점들을 담고 있습니다.
    * i번째 list의 j번째 값은 (i,j)가 연결되어 있음을 나타냅니다.
    * 즉 tree.get(i).get(j) 가 그 정보를 나타냅니다.
    * 이는 연결된 점에 대한 정보만 가지고 불필요한 정보를 가지지 않아 메모리면에서 인접행렬보다 훨씬 좋습니다.
2. 그리고 그래프를 dfs로 순회하며 찾아야하는 두 값을 찾습니다.
2. 찾으면서 list에 방문하는 점들을 저장하고 두 list를 비교하여 왼쪽부터 공통된 값을 찾는다.(backtracking)
    * 이 문제의 예시를 보면 8을 찾았을때 8을 찾기 위해 가지가 3에서 뻗어 나왔기 떄문에 그동안 지나온 노드들이 list에 저장됩니다(3,5,8)
    * 13을 찾았을 경우에는 다음과 같이 저장되어 있습니다(3,6,11,13)
3. 두 list를 왼쪽에서 부터 비교하여 제일 먼저 만나는 같은 값을 찾으면 그게 바로 공통 조상이 됩니다.
4. 찾은 공통 조상을 가지고 dfs롤 통해 그래프를 탐색해나가며 탐색한 정점의 수를 구하고 거기에 1을 더하면(자기 자신 포함) 서브트리의 크기가 됩니다.

# LCA(Lowest Common Ancestor) 알고리즘
이 문제를 찾아보니 꽤나 유명한 문제였습니다.  
이 방법을 간단히 설명하자면 찾으려는 두 정점의 높이를 같게하고 거기서 하나씩 똑같이 올려 가면서  같은 정점이 나올때까지 while문을 돌면 됩니다.  
같은 depth에서 시작했기에 depth를 똑같이 증가시키다 만난 같은 정점이 가장 가까운 공통 조상이 됩니다.  
그림이 그려져있는 첫번째 test case를 기준으로 설명드리겠습니다.

1. 부모를 타고 올라가면서 1이 될때까지 올라가며 각 점의 depth를 구합니다. (8은3, 13은 4)
2. 13의 depth가 더 깊으므로 13의 depth를 1 줄여서 맞추어 줍니다.(11에 위치하게 됨)
3. 여기서 동시에 부모를 타고 한 칸 올라갑니다. (8->5, 11->6)
4. 또 한칸 올라갑니다(8->5->3, 11->6->3) 이제 같아졌으므로 가장 가까운 공통 조상은 3임을 알 수 있습니다.
5. 그리고 이제 구한 공통 조상을 가지고 재귀를 통해 서브 노드의 개수를 구하면 됩니다.

# 왜 메모리 초과가 나올까??
직접 테스트 해본 결과 10000x10000으로 배열을 생성하게 되면 메모리를 500mb정도를 잡아먹습니다. 그렇기 때문에 당연한 결과입니다. 1억개의 공간을 사용하기 때문입니다.
그에 반해 10000개의 리스트를 생성하면 10mb도 안됩니다. 여기에 9999개의 정보를 집어 넣어도 이차원 배열로 인접행렬로 구성한 것에 비해 매우 적습니다.
* 결론: 그래프의 최대 크기를 보고 너무 크면 리스트로 구현하자. (왠만하면 리스트 구현으로 연습하자!)