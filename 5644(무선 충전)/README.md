# <span style="color:orange; font-size:17pt; font-weight:bold">sw expert academy 5644번 무선 충전 자바(java)  풀이</span>
- 모의 SW 역량 테스트
- [sw expert academy 2383번 점심 식사시간](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5-BEE6AK0DFAVl)

## [티스토리 주소](https://hoho325.tistory.com/)

# <span style="color:blue; font-size:17pt; font-weight:bold">문제 정리</span>
1. 스마트폰을 무선충전 할 때, 최적의 배터리 충전을 선택하는 알고리즘을 개발하려 한다.
2. 충전 범위가 K이면 BC와의 맨해튼 거리가 K이하이면 BC에 접속할 수 있다.
3. 만약 범위가 겹치는 곳에 있다면 그 중에 하나를 선택하여 접속할 수 있다.
4. 범위 안에 있으면 접속한 BC의 성능만큼 배터리를 충전할 수 있다.
5. 만약 한 BC에 두 명의 사용자가 접속한 경우, 접속한 사용자의 수 만큼 충전 양을 균등하게 분배한다.
6. BC의 정보와 사용자의 이동 궤적이 주어졌을 때, 모든 사용자가 충전한 양의 합의 최대값을 구하여라
7. 지도의 가로세로 크기는 10이며 사용자는 2명이다. 사용자 A는 (1,1)출발 B는 (10,1)에서 출발한다
8. BC의 개수 A는 최대 8개이다
9. BC의 성능은 500이하의 짝수이다.
10. 사용자 A,B는 동시에 같은 위치에 있을 수 있다.
11. 0: 이동하지 않음, 1: 상, 2: 우, 3: 하, 4: 좌
<br><br>

이 문제는 생각보다 간단하지만 쉽지 않았습니다. 조오금 헤맸습니다 ㅠㅠ  
정말 문제에서 주어진 그대로 풀었습니다. 그대로 풀면 되는 시뮬레이션 문제입니다.  

# <span style="color:blue; font-size:17pt; font-weight:bold">자료형 정리</span>
* track[2][M+1]: 사용자의 이동경로 담기, 사용자가 2명이고 이동경로는 첫 위치 포함(움직이지 않은 상태) M+1개 이므로 다음과 같이 선언합니다.
    그리고 track[0][]에는 A 사용자의 움직임
    track[1][]에는 B 사용자의 움직임을 담습니다.
* bc[A][4]: 이는 BC의 정보를 담습니다. x,y 좌표는 (0,0) ~ (9,9)위치를 사용하기 위해 각각 위치를 -1을해 조정해줍니다.
    bc[i][0] : BC의 x좌표
    bc[i][1] : BC의 y좌표
    bc[i][2] : BC의 범위
    bc[i][3] : BC가 충전해주는 양
* pqa(우선순위 큐): BC와의 범위 안에 들어가는 것들을 넣습니다. BC 번호와 충전 양을 큐에 넣습니다. 그리고 더 큰 충전 양을 가지는 BC를 선택하기 위해서 내림차순으로 정렬합니다.
<br><br

# <span style="color:blue; font-size:17pt; font-weight:bold">문제 풀이</span>
1. 방향에 맞춰 이동하기 위한 xdir, ydir을 선언합니다. 예를들어 dir이 1, 즉 위로 움직인다면 x좌표는 -1 작아지고 y좌표는 그대로입니다. 이를
    xdir[1] = -1, ydir[1] = 0으로 작성하여 해당 값을 더해줍니다.
2. 초기 위치를 설정합니다. apos[2]와 bpos[2]에 각각 사용자의 x,y 좌표를 담습니다.
3. track 위치에 맞추어 이동을 시작합니다.
4. 이동 후 모든 BC와의 거리를 계산 후, dist가 BC의 range 이하이면 우선순위 큐에 넣습니다.
5. 둘다 범위안에 가능한 BC가 있다면 우선 둘이 겹치는 BC인지 확인합니다. 겹치지 않는다면 큐에서 빼서 그 충전양을 더해줍니다.(내림차순이므로 그게 제일 큰 충전양임)
    - A만 가능한게 있다면 pqa에서 빼서 더해줍니다.
    - B만 가능한게 있다면 pqb에서 빼서 더해줍니다.
6. 겹친다면 둘다 1개 밖에 없는지 확인합니다. 둘 다 1개 밖에 없다면, 그 겹치는 BC의 충전양을 더해주면 됩니다. (나눠가져 써도 합치면 BC의 충전양 하나가 더해진다)
    - 두개 모두 1개 이상이 있다면 서로 다른 BC의 charge 값이 같을 수 있으므로 이를 check 하여 더 큰 값을 사용합니다. 상위 2개를 큐에서 꺼내서 A는 1번 B는 2번 / A는 2번, B는 1번을 사용하는 경우를 따져서 더 큰 값을 더해줍니다.
    - 둘 중 하나만 두개 이상이라면 두 개 이상을 가지는 사용자는 두번째로 charge가 큰 BC를 이용합니다
7. 이동하면서 더해진 충전 양 값(sum)을 반환하여 출력합니다.