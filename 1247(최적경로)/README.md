# sw expert academy 1242번 최적 경로 자바(java)  풀이
- [sw expert academy 1242번 최적 경로](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15OZ4qAPICFAYD)

## [티스토리 주소](https://hoho325.tistory.com/)

# 문제정리
1. 회사에서 출발하여 N명의 고객을 모두 방문하고 집으로 돌아오는 경로 중 가장 짧은 것을 찾는다.
2. 모든 좌표는 다르게 주어진다.
3. 문제에 쓰여있듯이 모든 경우를 따져주면 된다.

# 문제풀이
- 완전 탐색 (Solution.java)
0. 좌표를 편하게 입력받기 위해 x,y 좌표를 저장할 Pos 클래스를 선언한다.
1. 입력을 받아 집, 회사 좌표를 따로 저장한다.
2. 고객들의 좌표를 배열에 저장한다.
3. dfs를 통해 고객들의 좌표의 나열 가능한 모든 경우를 구한다(순열)
4. 이동한 거리를 재귀를 통해 넘길때 현재 선택한 집과 이전 집의 거리를 더해서 넘긴다.
5. N개의 집을 모두 선택해 나열했다면 마지막으로 선택한 집과 회사와의 거리를 더해주고 min 보다 작으면 갱신해준다.

- DP 기법 이용 (Solution2.java)
TSP(Traveling Salesman Problem), 비트 마스킹 방법을 이용하여 풀 수 있습니다.   
오른쪽에서 부터 i번째 수가 1이면 i번째 도시를 방문했음을, 0이면 방문하지 않았음을 의미합니다.  
예를 들어 5개의 도시가 있고 1,2,3번 도시를 방문했다면 00111로 표현합니다.  
이미 방문한 도시들과 현재 위치한 도시가 같을 때, 나머지 도시들을 방문하고 출발 도시로 돌아가는 최소 비용은 같습니다.  
1-2-3-4-5 와 2-1-3-4-5 두 가지 방법으로 가능하다면 3번 도시 뒤의 점들은 같기 때문에 한 번만 계산할 수 있습니다.  

dp[i][j] : 이미 방문한 도시들의 집합이 i이고 현재 있는 도시가 j일때, 방문하지 않은 나머지 도시들을 모두 방문한 뒤 출발 도시로 돌아올 때 드는 최소 비용.
0. 재귀로 구현합니다.
1. 방문 했음을 비트마스킹으로 체크 합니다. (visit |= (1 << now))
2. 모든 집들을 방문 했다면 마지막 방문지에서 집까지의 거리를 반환합니다.
3. 이미 계산한 값이 있다면 그 값을 반환합니다.
4. for문을 돌며 지금 방문하려는 점이 아니고(now가 아니고) 방문한 점이 아닌 경우 방문하여 거리를 누적하여 구합니다.